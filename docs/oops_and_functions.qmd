---
title: "oops_and_functions"
format: html
---

# Day 4: Task & Activities

## For loops

#### Task 1

```{r}
# Create two sequences, one called weekdays that contains days of the week (“Monday”, “Tuesday”, “Wednesday”, etc.) and one called transects that contains the series of transect names “Transect A”, “Transect B,”Transect C”. Write a nested for loop that creates a matrix containing the following:
weekdays <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
transect_1 <- c("Transect A", "Transect B", "Transect C") 

weekday_transects <- matrix(nrow = length(weekdays), ncol = length(transect_1))
library(stringr)

for(m in seq_along(weekdays)) {
  for(n in seq_along(transect_1)) {
       weekday_transects[m, n] <- paste(weekdays[m], "-", transect_1[n])

  #   if(stringr::str_detect(i, "A")){
  #       weekday_transects <- paste(weekdays[i], "-", transect_1[i])
  #   } else if (stringr::str_detect(i, "B")){
  #       weekday_transects <- paste(weekdays[i], "-", transect_1[i])
  # }
  # weekday_transects <- as.matrix(weekday_transects)
}}
weekday_transects


```

# Introducing Functions

```{r}
# Write a function called force that calculates a force (in Newtons), given inputs of mass (in kg) and acceleration (in m/s^2)
#  
#  (recall: F = ma
# ), and returns a statement “The resulting force is ___ Newtons.”
force <- function(mass, acceleration) {
  print(paste("The result force is" , mass*acceleration, "Newtons."))
}

force(10,20)

```

#### Task 3

```{r}
# The length:weight relationship for fish is: 
# , where where L is total fish length (centimeters), W is the expected fish weight (grams), and a and b are species-dependent parameter values (shown below for several fish from Peyton et al. 2016).

fish_parms <- data.frame(sci_name = c("Chanos chanos", "Sphyraena barracuda", "Caranx ignobilis"), common_name = c("Milkfish", "Great barracuda", "Giant trevally"), a_est = c(0.095,0.0181, 0.0353), b_est = c(2.52, 3.27,3.05))

head(fish_parms)

fish_weight <- function(fish_name, tot_length){
#subset to only keep rows where column_name matches fish_name, otherwise considers milkfish for all three (returns three calculations for other species)!
  parameters <- fish_parms[fish_parms$common_name == fish_name, ] # keep columns, but subset for rows that match argument
    # W = fish_parms$a_est*(tot_length^fish_parms$b_est)
 W = parameters$a_est*(tot_length^parameters$b_est)
  print(W)  
}
fish_weight("Great barracuda", tot_length = c(0:100))

# Now, try creating a vector of lengths (e.g. 0 to 100, by increments of 1) and ensuring that your function will calculate the fish weight over a range of lengths for the given species (try this for milkfish, storing the output weights as milkfish_weights.


```

#### Task 4

```{r}
# Write a function called wave_power that calculates potential ocean wave power given inputs of wave height and period.
# 

#wave_heights <- seq(from = 0, to = 3, by = .2)
# wave_range <- max(h) - min(h)
# wave_heights <- seq(from = 0, to = 3, by = .2)
# # wave_range <- max(h) - min(h)
# 
# # wave_powers <- vector(mode = "numeric", length = length(wave_heights))
# 
# wave_powers <- vector(mode = "numeric", length = length(wave_heights))

# wave_power <- function(h,t){
#   for(i in seq_along(h)){
#    p <- 0.5*(h)^2*(t)
#      wave_powers[i] <- p 
#      return(wave_powers[i])
#   }
# }


wave_power <- function(h,t){
   p <- 0.5*(h)^2*(t)
   return(p)
  }



pwr <- wave_power(h= seq(from = 0, to = 3, by = .2), 8)
pwr[2]
pwr[[2]]



# Use your wave_power function to approximate wave power for a period of 8 seconds, over a range of wave heights from 0 to 3 meters by increments of 0.2 meters.


```

# Additional practice and notes

```{r}
#adds up # of birds and dogs
#defined function, now need to use
birddog_sum <- function(bird, dog){
  pets <- bird + dog
  return(pets)
}

#use it
total_pets <- birddog_sum(bird = 2 , dog = 5)

# create a function to double values
double_it <- function(x){
  print(2*x)
}


animal_age <- function(animal, age){
if(animal == "dog") {
  print(age *7)
} else if(animal == "goat") {
  print(age*4.7)
}
  
}

animal_age("cow", 8)

# updated with error/warning messages
animal_age_stop <- function(animal, age){
if(!animal %in% c("dog", "goat")) {
  stop("Oops! Animal must be a dog or goat.")
}
  if(is.numeric(age) == F){
    stop("Age must be a number.")
  }
  if(age <= 0 | age > 50){
    warning("are you sure??")
  }
  if(animal == "dog") {
  print(age *7)
} else if(animal == "goat") {
  print(age*4.7)
    
} 
  }

animal_age_stop(animal = "dog", age = "yellow")
animal_age_stop(animal = "goat", age = 100)

df_means <- function(df) {
for(i in 1:ncol(df)){
  # all the data frames in function are called df
  if(is.numeric(df[[i]])) {
    col_name <- colnames(df[i]) # find these #step through each column
col_mean <- mean(df[[i]], na.rm = T)
print(paste("The mean value", col_name, "is", col_mean))
  }

# if(!is.numeric(col_mean)) {
#   warning("This is not a numeric!")
# }
# }
}
  }

df_means(df = mtcars)
df_means(df = palmerpenguins::penguins )


#logistic growth example
logistic_growth <- function(N_0, k, r, t) {
  Nt <- k/(1+((k-N_0)/N_0)*exp(-r*t))
  print(Nt)
}

logistic_growth(N_0 = 100, )

time_vec<- seq(from = 0, to = 35, by = .01)
# apply to this vector
pop_35 <- logistic_growth(100, k = 6000, r = 0.27, t= time_vec)
pop_time_35 <- data.frame(time_vec, pop_35)

library(ggplot2)
pop_time_35 |> ggplot(aes(x = time_vec, y = pop_35)) + geom_line()

#preallocated storage for output
pop_35_vec <- vector(mode = "numeric", length = length(time_vec))
#stepping through time steps
for(i in seq_along(time_vec)){
population <- logistic_growth(100, 6000, .27, time_vec[i])
pop_35_vec[i] <- population
}



```
